<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <title>SICP Graph - Hierarchical Edge Bundling</title>
  <style>
    body { margin: 0; background: #fff; }
    #graph-select {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1;
      padding: 5px;
      font-size: 14px;
    }
    #bundle-slider {
      position: absolute;
      top: 10px;
      left: 200px;
      z-index: 1;
    }
    #bundle-slider label {
      font-size: 14px;
      margin-right: 5px;
    }
    .node text {
      font: 10px sans-serif;
    }
    .node:hover text {
      font-weight: bold;
    }
    .link {
      fill: none;
      stroke-opacity: 0.4;
      stroke-width: 1.5px;
    }
    .link:hover {
      stroke-opacity: 1;
    }
  </style>
</head>

<body>
  <select id="graph-select">
    <option value="sicp">sicp</option>
    <option value="sicm">sicm</option>
    <option value="sicp_tfidf">sicp_tfidf</option>
    <option value="dirac">dirac</option>
    <option value="dirac_sections">dirac_sections</option>
    <option value="som">som</option>
  </select>
  <div id="bundle-slider">
    <label>Bundle strength:</label>
    <input type="range" id="tension" min="0" max="100" value="85">
    <span id="tension-value">0.85</span>
  </div>
  <div id="graph"></div>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script type="module">
  import chroma from 'https://esm.sh/chroma-js';

  const type = new URLSearchParams(location.search).get("type") || "sicp";
  const select = document.getElementById('graph-select');
  select.value = type;
  select.onchange = () => location.search = `?type=${select.value}`;

  const width = window.innerWidth;
  const height = window.innerHeight;
  const radius = Math.min(width, height) / 2 - 120;

  const graph = await fetch("json/" + type + ".json").then(r => r.json());

  // Create color scale based on groups
  const groups = [...new Set(graph.nodes.map(n => n.group))].sort();
  const colorScale = chroma.scale('Spectral').colors(groups.length);
  const getColor = (group) => colorScale[groups.indexOf(group)];

  // Build hierarchy: root -> groups -> nodes
  const groupedNodes = {};
  graph.nodes.forEach(node => {
    if (!groupedNodes[node.group]) {
      groupedNodes[node.group] = [];
    }
    groupedNodes[node.group].push(node);
  });

  const hierarchyData = {
    name: "root",
    children: groups.map(group => ({
      name: group,
      children: groupedNodes[group].map(node => ({
        name: node.id,
        displayName: node.name || node.id,
        group: node.group,
        wordcount: node.wordcount
      }))
    }))
  };

  // Create node id to path mapping
  const nodeMap = new Map();
  graph.nodes.forEach(node => {
    nodeMap.set(node.id, `root.${node.group}.${node.id}`);
  });

  // Create SVG
  const svg = d3.select("#graph")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", `translate(${width / 2},${height / 2})`);

  // Create cluster layout
  const cluster = d3.cluster()
    .size([360, radius]);

  // Process hierarchy
  const root = d3.hierarchy(hierarchyData);
  cluster(root);

  // Create a map from node id to cluster node
  const leaves = root.leaves();
  const leafMap = new Map();
  leaves.forEach(leaf => {
    leafMap.set(leaf.data.name, leaf);
  });

  // Line generator with tension/bundling
  let tension = 0.85;
  const line = d3.lineRadial()
    .curve(d3.curveBundle.beta(tension))
    .radius(d => d.y)
    .angle(d => d.x * Math.PI / 180);

  // Function to find path between two nodes
  function findPath(source, target) {
    const path = [];
    let current = source;

    // Go up from source to common ancestor
    const sourceAncestors = [];
    let temp = source;
    while (temp) {
      sourceAncestors.push(temp);
      temp = temp.parent;
    }

    // Find common ancestor and path from target
    const targetPath = [];
    temp = target;
    while (temp && !sourceAncestors.includes(temp)) {
      targetPath.unshift(temp);
      temp = temp.parent;
    }

    // Build full path
    const commonAncestor = temp;
    const idx = sourceAncestors.indexOf(commonAncestor);
    for (let i = 0; i <= idx; i++) {
      path.push(sourceAncestors[i]);
    }
    path.push(...targetPath);

    return path;
  }

  // Draw links
  const links = svg.append("g")
    .attr("class", "links")
    .selectAll("path")
    .data(graph.edges.filter(e => leafMap.has(e.source) && leafMap.has(e.target)))
    .join("path")
    .attr("class", "link")
    .attr("stroke", d => {
      const sourceNode = leafMap.get(d.source);
      return getColor(sourceNode.data.group);
    })
    .attr("d", d => {
      const source = leafMap.get(d.source);
      const target = leafMap.get(d.target);
      if (!source || !target) return null;
      const path = findPath(source, target);
      return line(path);
    });

  // Draw nodes
  const node = svg.append("g")
    .attr("class", "nodes")
    .selectAll("g")
    .data(leaves)
    .join("g")
    .attr("class", "node")
    .attr("transform", d => `rotate(${d.x - 90}) translate(${d.y},0)`)
    .on("mouseover", handleMouseOver)
    .on("mouseout", handleMouseOut);

  node.append("circle")
    .attr("r", d => Math.max(3, Math.log(d.data.wordcount || 5)))
    .attr("fill", d => getColor(d.data.group));

  node.append("text")
    .attr("dy", "0.31em")
    .attr("x", d => d.x < 180 ? 6 : -6)
    .attr("text-anchor", d => d.x < 180 ? "start" : "end")
    .attr("transform", d => d.x >= 180 ? "rotate(180)" : null)
    .text(d => d.data.displayName);

  // Highlight functions
  function handleMouseOver(event, d) {
    const connected = new Set();
    connected.add(d.data.name);

    graph.edges.forEach(e => {
      if (e.source === d.data.name) connected.add(e.target);
      if (e.target === d.data.name) connected.add(e.source);
    });

    node.style("opacity", n => connected.has(n.data.name) ? 1 : 0.2);
    links.style("stroke-opacity", e =>
      (e.source === d.data.name || e.target === d.data.name) ? 0.8 : 0.05
    );
  }

  function handleMouseOut() {
    node.style("opacity", 1);
    links.style("stroke-opacity", 0.4);
  }

  // Tension slider
  const tensionSlider = document.getElementById("tension");
  const tensionValue = document.getElementById("tension-value");

  tensionSlider.oninput = function() {
    tension = this.value / 100;
    tensionValue.textContent = tension.toFixed(2);

    line.curve(d3.curveBundle.beta(tension));

    links.attr("d", d => {
      const source = leafMap.get(d.source);
      const target = leafMap.get(d.target);
      if (!source || !target) return null;
      const path = findPath(source, target);
      return line(path);
    });
  };
  </script>
</body>
</html>
